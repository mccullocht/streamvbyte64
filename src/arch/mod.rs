/// Module containing architecture-specific utility code.

#[cfg(all(target_arch = "aarch64", target_endian = "little"))]
pub(crate) mod neon;

/// These functions accept a mapping from tag value -> byte length and use that to generate a table
/// that can be used to shuffle an input group to compress it.
///
/// These functions are generated by macro because we can't alter the output type using generics
/// unless we use unstable features.
macro_rules! generate_encode_shuffle_table {
    ($name:ident, $elem_type:ty) => {
        #[allow(dead_code)]
        pub(crate) const fn $name(
            tag_len: [usize; 4],
        ) -> [[u8; std::mem::size_of::<$elem_type>() * 4]; 256] {
            // Default fill with 128 to ensure zero-fill of any unset indices.
            // x86_64 pshufb checks the high bit to zero fill and neon vtbl may address up to 64
            // bytes and zero-fills anything larger so this should cover both cases.
            let mut table = [[128u8; std::mem::size_of::<$elem_type>() * 4]; 256];
            let mut tag = 0usize;
            while tag < 256 {
                let mut shuf_idx = 0;
                let mut i = 0;
                while i < 4 {
                    let vtag = (tag >> (i * 2)) & 0x3;
                    let mut j = 0;
                    while j < tag_len[vtag as usize] {
                        table[tag][shuf_idx] = (i * std::mem::size_of::<$elem_type>() + j) as u8;
                        shuf_idx += 1;
                        j += 1;
                    }
                    i += 1;
                }
                tag += 1;
            }
            table
        }
    };
}
generate_encode_shuffle_table!(tag_encode_shuffle_table32, u32);
generate_encode_shuffle_table!(tag_encode_shuffle_table64, u64);

/// These functions accept a mapping from tag value -> byte length and use that to generate a table
/// that can be used to shuffle a compressed input into an output group.
///
/// These functions are generated by macro because we can't alter the output type using generics
/// unless we use unstable features.
macro_rules! generate_decode_shuffle_table {
    ($name:ident, $elem_type:ty) => {
        #[allow(dead_code)]
        pub(crate) const fn $name(
            tag_len: [usize; 4],
        ) -> [[u8; std::mem::size_of::<$elem_type>() * 4]; 256] {
            // Default fill with 128 to ensure zero-fill of any unset indices.
            // x86_64 pshufb checks the high bit to zero fill and neon vtbl may address up to 64
            // bytes and zero-fills anything larger so this should cover both cases.
            let mut table = [[128u8; std::mem::size_of::<$elem_type>() * 4]; 256];
            let mut tag = 0usize;
            while tag < 256 {
                let mut shuf_idx = 0;
                let mut i = 0;
                while i < 4 {
                    let vtag = (tag >> (i * 2)) & 0x3;
                    let mut j = 0;
                    while j < tag_len[vtag as usize] {
                        table[tag][i * std::mem::size_of::<$elem_type>() + j] = shuf_idx;
                        shuf_idx += 1;
                        j += 1;
                    }
                    i += 1;
                }
                tag += 1;
            }
            table
        }
    };
}
generate_decode_shuffle_table!(tag_decode_shuffle_table32, u32);
generate_decode_shuffle_table!(tag_decode_shuffle_table64, u64);
